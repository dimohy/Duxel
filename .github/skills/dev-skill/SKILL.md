---
name: "개발 스킬"
description: "코드 생성 시점에 발동하며 fallback 코드는 절대로 구현하지 않는다."
version: "1.1"
owner: "team"
---

# 목적
- 코드 생성 시점에만 적용한다.
- fallback 코드는 절대로 구현하지 않는다.

# 적용 시점
- 코드 생성(새 파일/기능 구현/대량 코드 작성) 요청 시 자동 적용.

# 핵심 원칙
1. fallback 경로/대체 구현을 추가하지 않는다.
2. 미지원 환경/기능의 경우 명시적으로 실패하거나 구현하지 않는다.
3. 조건부 우회 로직(예: if failed then fallback)을 금지한다.
4. 컴파일 경고는 원칙적으로 해결한다.

# 컴퓨팅 사고(Computational Thinking) 적용 원칙
- 문제분해(Decomposition): 복잡한 문제를 기능/계층/데이터 흐름 단위로 분해한다.
- 패턴 인식(Pattern Recognition): 반복되는 구조·로직·UI 흐름·상태 변화를 식별해 재사용 가능한 패턴으로 통합한다.
- 추상화(Abstraction): 공통 개념을 인터페이스/추상 타입/규약으로 승격하고, 세부 구현은 캡슐화한다.
- 알고리즘화(Algorithmic Thinking): 입력→처리→출력의 절차를 명확히 정의하고, 단계적 검증 가능 구조로 만든다.

# 객체지향 및 SOLID 준수 원칙
- 단일 책임(SRP): 클래스/모듈은 하나의 변경 이유만 갖는다.
- 개방-폐쇄(OCP): 확장에는 열려 있고 수정에는 닫혀 있도록 추상화/다형성으로 설계한다.
- 리스코프 치환(LSP): 상위 타입 계약을 하위 타입이 위반하지 않도록 한다.
- 인터페이스 분리(ISP): 클라이언트가 필요로 하지 않는 메서드에 의존하지 않도록 인터페이스를 분리한다.
- 의존 역전(DIP): 고수준 정책은 저수준 구현이 아닌 추상화에 의존하도록 한다.

# 설계/패턴 적용 가이드
- 객체 간 책임/경계를 먼저 정의한 후 상호작용을 설계한다.
- 생성/조합/확장 지점을 분리하고, 결합도를 낮추며 응집도를 높인다.
- 공통 동작은 재사용 가능한 구성요소로 추출하되, 과도한 일반화는 지양한다.

# 참고(웹 근거)
- Computational Thinking: https://en.wikipedia.org/wiki/Computational_thinking
- SOLID Principles: https://en.wikipedia.org/wiki/SOLID

# 시각적 활성 표시
- 스킬이 실제로 적용되는 응답에는 눈에 띄는 표시를 포함한다.
- 예: "🟢 Skill Active: 개발 스킬" 같은 라벨을 응답 상단에 표기

# 금지 예시
- 실패 시 다른 백엔드로 자동 전환
- try/catch로 대체 동작 제공
- 런타임 분기 fallback 경로 추가

# 허용 예시
- 명확한 예외/오류 반환
- 명시적 미구현 표시
